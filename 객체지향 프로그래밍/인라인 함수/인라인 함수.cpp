#include <iostream>

using namespace std;

inline void Func()
{
	cout << "왜 인라인 함수를 쓰지?" << endl;
	cout << "도대체 인라인이 뭐야!" << endl;
	cout << "뭐! 내가 인라인이야?" << endl;
}

int main()
{
	Func(); 
	// 인라인 함수
	// 실제로는 함수를 호출하는대신 함수의 내용을 붙여놓는다
	// 함수를 호출하면 실행 흐름이 다른 함수로 돌아오는 작업이나 복사를 하는 과정에서 많은 부하가 일어나는데 인라인함수는 이런 작업들이 불필요하게 되므로 시간을 벌수있다
	// 하지만 인라인 함수는 함수의 내용이 몇줄정도 짧은 경우에만 인라인 함수로 만들자!
	//cout << "왜 인라인 함수를 쓰지?" << endl;
	//cout << "도대체 인라인이 뭐야!" << endl;
	//cout << "뭐! 내가 인라인이야?" << endl;

	// 인라인 함수를 만드는 법에는 두 가지가 있다
	// 클래스의 내부에 정의한 멤버 함수들은 모두 자동으로 인라인 함수가 된다
	// 클래스의 외부에 정의한 멤버 함수는 함수의 정의 앞에 inline 키워드를 추가 한다

	// 또한 멤버가 아닌 함수도 인라인이 될 수 있다

	// 한가지 주의할 점은 우리가 인라인 함수로 만들고 싶다고 해서 항상 인라인 함수가 되는 것은 아니다
	// 우리는 단지 컴퓨터에게 될 수 있으면 이 함수를 인라인으로 만들고 싶어 라고 말할 수 있을 뿐
	// 정말로 인라인 함수로 만들지는 컴퓨터가 결정한다
	// 일반적으로 재귀 함수인 경우나 누군가가 그 함수의 주소를 얻어서 사용하는 경우에는 인라인 함수가 되지 않는다
	
	// 인라인 함수는 반드시 헤더 파일에 있어야 한다
	// 인라인 함수가 클래스의 정의 내부에 있는 경우 -> 어차피 클래스의 정의는 헤더 파일에 위치하므로 특별히 신경 써줄 것이 없다
	// 인라인 함수가 클래스의 정의 외부에 있는 경우 -> 함수의 정의를 헤더 파일에 위치시켜야 한다

	return 0;
}

// 인라인 함수의 단점
// 프로그램의 크기가 커진다
// 인라인 함수를 많이 써서 프로그램의 코드가 커지면 오히려 프로그램의 수행 속도가 떨어질 수 있다
// 하드디스크에 있는 실행 파일이 메모리에 올라갔다 내려왔다 하는 일이 더욱 자주 반복되기 때문이다
// 어떤 인라인함수가 10줄의 코드를 가지고 있고 이 함수를 호출하는 곳이 100군데가 있으면
// 이 100군데에다 10줄의 코드를 붙이는것이므로 10*100줄의 코드가 된다..
// 그렇기 때문에 긴 함수를 인라인으로 만들지 말자!
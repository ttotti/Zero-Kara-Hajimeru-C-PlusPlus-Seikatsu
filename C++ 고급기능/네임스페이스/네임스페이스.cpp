
// namespace 네임스페이스
// 실제 현장에서 개발하는 프로젝트는 수백 개 이상의 소스 파일로 이루어져 있다 그리고 이 파일들 안에는 수천, 수만 개의 이름이 존재한다
// 변수, 함수, 클래스, 구조체, 열거체, 타입 재정의(typedef)를 사용할 때마다 새로운 이름이 생겨나는 것이므로 충분히 수만 개에 달할 수 있다
// 또한 전역 공간에서 정의한 이름들이라면 서로 다른 소스 파일에 위치한다고 해도 동일한 이름의 변수를 두 번 정의했다는 오류를 뿜는다
// 이런 상황은 폴더 개념이 없는 하드디스크에 비유할 수 있다
// 분명 많은 파일들이 서로 이름 충돌을 일으킬 것이고 혼잡하게 뒤섞인 파일에서 필요한 것을 꺼내오는 것은 힘든 일이 될 것이다
// C++ 에서는 네임 스페이스가 폴더와 같은 역할을 해준다
// 전역 공간에 존재하는 수많은 코드들을 네임스페이스라는 가상의 폴더에 넣어서 보관하게 되면 이름이 충돌할 염려도 없고 관련한 코드들을 한 곳에 모을 수 있어서 좋다
// 또한 가장 큰 장점인 소스 파일과 코드를 구조적으로 관리할 수 있다는 점이다
// Date 네임스페이스 안에는 정보를 저장하거나 읽어오는 작업에 관련된 코드르 넣고
// UserInterface 네임스페이스 안에는 프로그램의 UI와 관련된 코드들을 넣어두게 되면 소스코드르 관리하는데 많은 장점을 갖게 된다

// 네임스페이스 안에서 정의한 변수는 전역 변수에 해당한다 접근 범위와 존속 기간 역시 전역 변수와 동일하다
// 네임스페이스 안에서 정의했기 때문에 사용할 때 부가적으로 해주어야 할 일이 있기는 하지만 여전히 모든 파일에서 접근할 수 있다

// 이 예제이서 중요한 부분은 같은 이름들이 여러 번 등장한다는 점이다
// Info, count, CreateAll() 등의 이름이 중복된다 또한 count라는 이름은 전역 공간에 정의한 것까지 3개나 있다
// 하지만 컴퓨터는 아무런 오류를 뿜지 않는다 마치 하드디스크에서 서로 다른 폴더라면 같은 이름의 파일이 존재할 수 있는 것과 같다

// 멍멍이와 관련된 것들
// Dog 네임스페이스 안에 멍멍이와 관련된 이름들을 정의했다
namespace Dog
{
	// 멍멍이 한 마리 정보
	struct Info
	{
		char name[20];
		int age;
	};

	Info dogs[20]; // 멍멍이 리스트
	int count;	   // 전체 멍멍이들의 수

	void CreateAll(); // 모든 멍멍이 생성 함수
}

// Cat 네임스페이스 안에 야옹이와 관련된 이름들을 정의했다
namespace Cat
{
	// 야옹이 한 마리 정보
	class Info
	{
	public:
		void Meow();
	protected:
		char name[20];
	};

	Info cats[20]; // 야옹이 리스트
	int count;	   // 전체 야옹이들의 수

	void CreateAll(); // 모든 야옹이 생성 함수
}

int count;

// 아래와 같이 영역 지정 연산자를 항상 쓰는것은 불편할 수 있다
// 그래서 using 키워드를 사용해 네임스페이스를 선언해주면 지금부터 말하는 이름들은 Cat네임스페이스에 소속한 이름들을 말하는 거야 처럼 선언해줄 수 있다
// 만약 main() 함수에서 야옹이와 관련한 작업만 할 예정이라면 유용한 방법이 될 것이다
using namespace Cat;
// 하지만 야옹이 멍멍이와 관련한 작업을 모두 포함해야 한다면 using 키워드를 사용해서 네임스페이스를 지정하는 방법은 권장하지 않는다
// 두 개의 네임스페이스에는 동일한 이름을 가지고 있는 변수와 함수가 있기 때문에
// main() 함수에서 동일한 이름을 사용했을 경우 컴퓨터는 어떤 네임스페이스의 이름을 사용해야 할지 모르겠다는 오류를 뿜게된다
// 이런 경우는 다시 Cat::CreateAll() 와 같이 영역 지정 연산자(::) 를 사용해서 지정하는 수밖에 없다
// (using 키워드를 사용해서 네임스페이스를 지정한 경우라도 Cat::count와 같은 표현을 사용할 수 있다)
using namespace Dog;

// using 키워드를 사용해서 네임스페이스의 전체가 아닌 소속된 특정 이름만 지정하는 것도 가능하다
// 이는 이제부터 말하는 CrearteAll은 Cat 네임스페이스에 소속한 CreateAll을 말하는 거야 라고 선포하는 것이다
// 그렇기 때문에 CreateAll() 이라고만 적어주어도 컴퓨터는 Dog::CreateAll 와 혼동하지 않고 올바른 호출을 할 수 있다
// 하지만 이것은 주의해야 할 점이 있는데
// Cat::CreateAll 이라는 이름은 전역 공간에서 다시 한번 선언되는 효과를 갖는다
// 마치 전역 공간에 CreateAll() 이라는 함수를 선언한 것과 같다는 뜻이다
// 그렇기 때문에 만약 다른 전역 공간에 CreateAll()이라는 이름의 함수가 선언된다면 오류를 뿜는다
using Cat::CreateAll;
// void CreateAll(); // 오류 이름 충돌

int main()
{
	// 네임스페이스를 만들고 그 안에있는 변수나 함수를 무작정 사용하려고 하면 이름을 찾을수없다고 오류를 뿜는다
	// 그러므로 사용하기 위해 Cat이라는 네임스페이스 안에 있는 CreateAll() 함수를 호출해주렴 과 같은 방식을 사용해야한다
	// CreateAll(); 오류
	// cats[0].Meow(); 오류

	// Cat:: 과 같은 문법은 Cat 네임스페이스에 소속된... 이라는 표현을 하고 있다
	// :: 라는 연산자는 영역 지정 연산자(Scope resolution operator) 라는 이름이 있다
	// 그리고 이와 같이 클래스의 멤버를 가리키거나 네임스페이스에 소속한 이름을 가리킬 때 사용한다
	Cat::CreateAll();
	Cat::cats[0].Meow();
	Dog::CreateAll();
	int dog_count = Dog::count;

	return 0;
}
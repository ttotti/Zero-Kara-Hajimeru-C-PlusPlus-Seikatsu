#include <iostream>
#include "dynamic_cast.h"
#include "Complex.h"

using namespace std;

int main()
{
	// const_cast

	const int ci = 100;
	// int* p = &ci; 오류 // const형의 변수는 const형 포인터만 가리킬 수 있다
	// const_cast 연산자는 어떤 포인터 타입에서 const 속성이나 volatile 속성을 제거 할 때 사용한다(volatile 키워드는 인터넷 참고)
	// const_cast 연산자는 차례대로
	// 형변환된 값을 대입할 변수 = const_cast<형변환 할 타입>(형변환할 변수) 으로 사용되며
	int* p = const_cast<int*>(&ci); // 성공 // const int 타입을 int* 타입으로 형변환
	cout << *p << endl << endl;
	// 이렇게 형변환하여 포인터의 const 속성을 제거 된 변수의 값을 바꿀수 있다
	// 여기서 포인터 변수 p 가 int* 으로 형변환 된 ci를 가리키고 있으니 둘이 주소가 같다
	// 그러면 *p의 값을 바꾸면 주소를 따라 ci의 값도 바꿔야하는게 정상인데 출력을 해보면 바뀌지 않는다
	// 그 이유는 상수와 변수가 다루는 메커니즘에 있는데
	// 일반적인 변수는 스택이나 힙 공간에 저장되고 참조되지만
	// 상수의 경우 다른 특수한 세그먼트에 따로 저장이 되며 상수에 대한 포인터나 레퍼런스가 발생할 경우 그것을 가리키는 임시값이 생성된다
	// 그리고 일반적인 경우 상수를 가리키는 포인터는 똑같이 const형 이므로 수정이 불가능해서 상수처럼 보이는 것이고
	// 여기서 ci를 가리키는 포인터 p가 const의 속성을 제거함으로 수정은 가능했으나
	// 진짜 상수인 ci를 다시 참조해 보려 하면 원래 값이 튀어나오는 것도 상수 메커니즘이 따로 작동하기 때문이다
	// 사용법은 예를 들어
	// 일반적인 포인터를 매개변수로 사용하는 함수에 const 포인터를 넣을 수 없을 때 잠시나마 const성질을 제거해서 넣어줄수 있다
	// 그리고 C 스타일의 형변환에 비해 작성자의 의도가 명확하게 드러나며
	// 컴퓨터가 const 속성으로 제거하는 용도 외의 다른 종류의 형변환을 시도하게 되면 오류를 뿜는다(실수 방지)
	*p = 200; // 성공
	cout << *p << endl;
	cout << p << endl;
	cout << ci << endl;
	cout << &ci << endl;

	////////////////////////////////////////////////////////////

	// reinterpret_cast

	// reinterpret_cast 는 일반적으로 허용하지 않는 위험한 형변환을 할 때 사용한다
	// 이 형변환은 현재의 자료형에 상관없이 전부 강제로 대입해버릴수 있다
	// 주로 포인터의 자료형이 다를 때나 포인터를 정수(포인터가 아닌 변수)로 변환하는 등의 작업에 쓰인다
	int a;
	int* b;
	// a = b; 오류 // int* 형식의 값을 int 형식의 엔터키에 할당할 수 없습니다
	a = reinterpret_cast<int>(&b); // 성공

	////////////////////////////////////////////////////////////

	// static_cast

	// static_cast 는 가장 일반적인 형태의 형변환을 할 때 사용한다
	// 예를 들어 double 타입을 char 타입으로 형변환하는 데 사용할 수 있다
	// static_cast 는 명시적인 형변환이기는 하지만 대체적으로 안전한 형변환이라고 볼 수 있다
	// 아마도 지금까지 수행했던 대부분의 형변환은 static_cast의 범주에 속할 것이다
	// 구체적으로 A타입에서 B타입으로의 암시적인 형변환이 가능하다면 static_cast를 사용해서 B 타입에서 A타입으로 형변환할 수 있다
	// 예를 들어 int* 타입은 void* 타입으로 암시적인 형변환이 되기 때문에 static_cast를 사용해서 void* 타입을 int* 타입으로 변환할 수 있다
	double d = 30.0;
	char c;
	c = static_cast<char>(d);

	/////////////////////////////////////////////////////////////

	// dynamic_cast

	// RTTI(Runtime Type Information) 는 실행 시간에 객체의 타입에 대한 정보를 얻을 수 있는 기능 이다
	// 이 예제에서 dynamic_cast 연산자가 pa1이 가리키고 있는 객체가 실제로 A 클래스인지 C 클래스인지를 알아낼 수 있는 것은 RTTI 덕분이다
	// 클래스 A를 보면 아무 일도 하지 않는 가상 함수가 하나 있는데 dynamic_cast 를 사용하기 위해서 필요한 작업이다
	// 가상 함수가 하나도 없는 클래스는 dynamic_cast를 사용할 수 없기 때문인데 이는 RTTI의 내부 구현과 관련이 있다

	// 또한 비주얼스튜디오는 기본적으로 RTTI 기능을 사용하지 않게 설정되어 있는데
	// 하는 일이 많은 만큼 자체적인 부하(Overhead)를 가지고 있기 때문이다
	// 그래서 dynamic_cast 를 비롯한 RTTI의 기능을 사용하기 위해 프로젝트의 설정을 변경시킬 필요가 있다
	// 프로젝트 속성 -> C/C++ -> 언어 -> 런타임 형식 정보 사용 속성에서 예(/GR)로 변경한다

	// 업캐스팅 : 자식 객체 포인터를 부모 포인터로 형 변환하는 경우(상속 계층이 위로 이동)
	// 다운 캐스팅 : 부모 객체 포인터를 자식 포인터로 형 변환하는 경우(상속 계층이 아래로 이동)
	// (다운 캐스팅을 하는 경우 부모 클래스에는 존재하지 않지만 자식 클래스 내에 존재하는 멤버 함수를 호출하는 경우 에러가 발생할 수 있다)

	// dynamic_cast 란 서로 상속 관계에 있는 클래스간에 형변환을 할 때 사용한다 또한 형변환을 수행하는 동시에 이 형변환이 안전한 것까지 검사 해준다
	// 다운 캐스팅은 안전하지 않은 방법이다 하지만 필요한 경우가 있을때는 사용해야 하는데 이때 사용하는 키워드이다
	// 부모 객체를 자식 객체로 다운 캐스팅하려고 했을 때 위험한 경우 캐스팅을 허용하지 않으며 NULL을 반환한다

	// 다운 캐스팅이 혀용되는 기준은 '객체가 가리키고 있는 객체가 어떤 타입인가?' 이다
	// 즉 부모 객체가 자식 객체 주소를 가리키고 있는 경우 다운 캐스팅이 허용되며
	// 부모 객체가 부모 객체 주소를 가리키고 있는 경우는 다운 캐스팅이 허용되지 않는다

	// C 객체를 생성해서 A* 에 담는다
	// 부모 객체 A 가 자식 객체 C 의 주소를 가리키고 있다
	A* pa1 = new C;

	// A 객체를 생성해서 A* 에 담는다
	// 부모 객체 A 가 부모 객체 A의 주소를 가리키고 있다
	A* pa2 = new A;

	// pa1을 C* 타입으로 형변환한다
	// 다운 캐스팅 허용
	C* pc1 = dynamic_cast<C*>(pa1); // 성공

	// pa2를 C* 타입으로 형변환한다
	// 다운 캐스팅 불가
	C* pc2 = dynamic_cast<C*>(pa2); // 실패 : NULL 반환

	try
	{
		// *pa2를 C& 타입으로 형변환 한다
		// 다운 캐스딩 불가 (예외 발생)
		C& rc1 = dynamic_cast<C&>(*pa2); // 실패 : bad_cast 예외 발생
	}
	catch (bad_cast& e)
	{

	}

	/////////////////////////////////////////////////////////////////

	// 형변환 방법을 컴퓨터에게 알려주기
	// 형변환 연산자 오버로딩

	// 내가 만든 클래스를 다른 타입으로 형변환하기 // 클래스 타입 -> int 등
	Complex c1(10, 5);

	int aa;
	// 이제 Complex 객체를 int 타입으로 암시적으로 형변환할 수 있다
	// 형변환 연산자 오버로드가 없다면 이 코드는 오류가 난다 (Complex.h - 85줄 ~ 90줄)
	// operator double() 과 같은 원형으로 다른 타입의 형변환도 정의할 수 있다
	aa = c1; // i = 10
	aa = c1.operator int(); // 위의 코드와 동일한 일을 한다



	// 다른 타입을 내가 만든 클래스로 형변환하기 // int 등 -> 클래스 타입
	int bb = 5;
	Complex c2(0, 0);

	// 이제 int타입을 Complex 타입으로 암시적 형변환을 할 수 있다
	// (Complex.h - 96줄 ~ 98줄)
	c2 = bb; // c = (5, 0)
	c2 = Complex(bb); // 위의 코드와 동일한 일을 한다

	c2 = c2 + bb; // c = (10, 0)
	c2 = c2 + Complex(bb); // 위의 코드와 동일한 일을 한다

	// 사실 이 기능을 꽤 사용해왔다
	// 위의 코드를 보면 c = Complex(i) 가 있는데 마치 임시객체를 만드는 것처럼 보이지 않는가?
	// 생성자를 사용해서 임시 객체를 생성했다고 생각해도 좋고 형변환이 이루어졌다고 생각해도 좋다



	// explicit 키워드
	// 생성자 앞에 explicit 키워드를 붙여주면 그 이름처럼 명시적인 형변환만을 허용한다
	
	int cc = 10;
	Complex c3(0, 0);

	// 이 예제에는 생성자앞에 explicit 키워드를 붙이지 않아서 에러가 나지 않는다(확인해보고 싶으면 키워드를 붙여보자)
	c3 = cc; // 실패: 암시적인 형변환 불가능
	c3 = Complex(cc);				 // 성공
	c3 = (Complex)cc;				 // 성공
	c3 = static_cast<Complex>(cc); // 성공


	// 연산자 오버로드는 Complex 클래스나 문자열 클래스처럼 간편하게 사용할 수 있는 유틸리티 성격의 클래스들에게는 매우 유용하지만
	// 일반적인 클래스들은 연산자 오버로딩을 필요로 하지않는 경우가 대부분이다
	// 꼭 필요한 곳에 유용하게 적용하자!

	return 0;
}
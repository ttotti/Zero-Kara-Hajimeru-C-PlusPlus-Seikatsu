// C++ 스타일의 입출력
// C++ 스타일의 입출력이란 cin cout 객체를 사용한 입출력을 말한다

// 입출력의 구현
// 일단 헤더 iostream 헤더 파일에 보면 다음과 같이 cout, cin 객체를 선언하고 있다
// extern ostream cout;
// extern istream cin;
// extern 이 붙어있는걸 봐서 실제 객체의 정의는 어딘가 구현 파일에 있을 것이라고 예상할 수 있다
// 중요한 것은 ostream과 istream 클래스 타입을 갖는다는 점인데
// 사실 이들은 그냥 클래스가 아니라 템플릿 클래스를 다음과 같이 재정의한 타입이다
// typedef basic_ostream<char> ostream;
// typedef basic_istream<char> istream;

// 결국 cout과 cin 객체의 실제 클래스는 basic-ostream과 basic_istream 인 것이다
// 클래스의 이름을 보면 기본적인(basic) 출력(o) 스트림(stream) 기본적인 입력(i) 스트림 정도로 해석이 되는데
// 스트림이란 시내, 개울, 흐름 등의 사전적인 의미가 있다
// 그와 비슷하게 C++에서의 스트림은 연결된 통로로 흘러가고 있는 데이터를 연상하면 된다 (파일, 콘솔, 다른프로그램 -> 스트림 -> 내 프로그램)
// 스트림의 왼쪽에서 데이터를 넣으면 스트림의 오른쪽에 있는 내 프로그램에서 데이터를 꺼내서 사용한다
// 그것이 실제로 누구로부터 왔는지는 신경 쓰지 않아도 된다
// 결국 스트림의 양 끝에서 데이터를 주고 받는 객체가 서로에 대해서 모르는 상태에서도 데이터를 주고 받을 수 있다
// 즉 스트림을 통해서 서로간의 연관성(Coupling)이 없어지는 것이다
// 위와 같은 스트림은 입력 스트림이라고 볼 수 있는데 반대로 내 프로그램으로부터 파일이나 콘솔로 데이터를 실어 나르는 스트림이 출력 스트림이 된다
// 바로 basic_ostream 이나 basic_istream 클래스는 이러한 스트림을 구현해놓은 것이다

// basic_ostream과 basic_istream 클래스의 상속 구조도(실행 시 이미지 뜸 인터넷, 책874p 참고)

// 제일 아래쪽에 basic_istream과 basic_ostream 클래스가 있고 이 두 클래스 모두 basic_ios 클래스를 상속 받고 있다
// basic_ios는 입출력 스트림 클래스들에서 공통적으로 사용하는 기본 기능을 구현하고 있다
// 또한 스트림 내부적으로 사용하는 메모리를 관리하기 위한 basic_streambuf 클래스도 있다
// 그리고 그 위에는 ios_base 라는 최상위 클래스가 있는데 이 클래스는 출력을 예쁘게 만들 수 있는 여러가지 옵션을 구현하고 있다


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 버퍼링과 방출
// 출력 스트림을 사용해서 자료를 보낼 때 자료가 파일이나 콘솔 창으로 그 즉시 출력되는 것이 아니다
// 우선 받은 자료를 모아두었다가 적당한 양이 쌓이면 한 번에 콘솔 창이나 파일로 출력하게 된다
// 매번 보내는 것 보다 한 번에 모아서 보내는 것이 보다 효율적이기 때문인다
// 특히 파일에 자료를 출력하는 경우에는 더욱 그렇다
// 입력 스트림 또한 마찬가지로 파일이나 콘솔 창에서 한 번에 여러 바이트를 모아서 읽어온 후 조금씩 주는 방식을 사용한다
// 이렇게 데이터를 모았다가 보내는 작업을 버퍼링(Buffering) 이라고 부른다
// 일반적으로 자료가 어느 한 곳에서 다른 곳으로 이동할 때 잠시 보관되는 메모리를 버퍼 라 부르고
// 버퍼를 사용해서 모았다가 한 번에 보내는 것을 버퍼링 이라고 부른다 이는 C++ 뿐만 아닌 컴퓨팅 전반에 걸쳐서 사용하는 용어이다

// 그런데 가끔씩 버퍼링을 하지 않게 만들고 싶을 경우가 있는데
// 예를 들어 출력한 내용을 곧바로 다른 작업에 사용해야 한다면 될 수 있는 한 빨리 출력할 필요가 있다
// 이럴 때는 버퍼에 있는 내용을 지금 당장 배출(Flushing)하라는 명령을 내릴 수가 있는데 다음과 같은 두 가지 방법을 사용할 수 있다
// cout << "Hello, World~\n" << flush;
// cout << "Hello, World~" << endl;
// 두 줄의 코드는 동일한 일을 하고 있는데
// 첫번째 줄은 Hello, World~ 라는 문자열을 버퍼로 보낸 후에 버퍼의 내용을 그 즉시 출력하게 만든다
// 두번째 줄에서 쓰인 endl 은 개행문자(\n, 엔터)를 출력한 후에 버퍼의 내용을 방출하게 만든다
// 일반적으로 방출명령을 사용할 일은 거의 없지만 내부적으로 버퍼링을 수행한다는 사실은 꼭 기억하고 있어야 한다
// 만약 출력한 문자가 바로 출력되지 않는 문제를 만나게 되면 버퍼링을 의심해볼 수 있어야 한다


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 입출력 형식 지정하기
// 입출력 형식을 지정한다는 것은 한 마디로 출력을 예쁘게 꾸미는 것을 말한다
// 출력하는 값을 한 쪽으로 정렬한다던가 16진수로 출력하게 만든다거나 소수점 이하 자리 수를 제한하는 등의 작업을 말한다

// 입출력 형식을 지정하는 가장 기본적인 방법은 ios_base 클래스의 self() 함수를 사용하는 것이다 (자세한 내용은 인터넷, 책876p 참고)
// self() 함수의 인자에 넣을 수 있는 옵션은 여러가지가 있다 또한 지정한 옵션을 취소하는 방법도 있다
// 주의) 컴파일러의 내부 구현이 바꿘다면 제대로 작동하지 않을 수 있다

// 비트 마스크(Bit Mask) 를 사용한 인자 전달(인터넷, 책877p 참고)

// 그 밖에도 출력하는 값을 몇 칸에 걸쳐서 출력할지를 지정하는 width()
// 실수의 출력 방식에 따라서 다른 의미를 갖는 precision() (예) 소수점 이하 둘째 자리까지만 출력 등)
// 기본적으로 공백문자(Space)가 채워지는데 이 빈 칸을 채우는 문자를 지정하는 fill() 함수 등이 있다

// 조종자(Manipulator) 는 위에 있는 self() 함수나 기타 함수들을 쉽게 호출하는 방법으로
// cout << hex << 333 << endl; 이런 식으로 self()에 옵션으로 지정해야 하는 hex를 매우 간단하게 사용할 수 있다
// (여러 조종자들의 이름은 인터넷, 책880p을 참고한다)
// 또한 iomanip 헤더 파일에 인자를 받을 수 있는 조종자를 몇 개 더 정의하고 있다
// 예를 들어 width() 함수를 호출하는 대신 다음과 같이 조종자를 사용할 수 있다
// cout << setw(10) << 333 << endl;
// (iomanip 헤더 파일에 있는 조종자들은 인터넷, 책881p 참고)


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 그 밖의 입출력 기능들
// 스트림은 내부적인 상태를 갖고 그 상태에 따라서 다르게 행동한다

// basic_ios 클래스에는 스트림의 상태를 확인할 수 있는 4개의 멤버 함수가 있다
// 각 함수는 bool 값을 반환하며 반환 값의 의미는 다음과 같다
// bool good() const; // true면, 정상적인 상태
// bool eof() const;  // true면, 파일이나 입력의 끝이 도달
// bool fail() const; // true면, 예상치 못한 입력이 들어오는 등의 문제 발생
// bool bad() const;  // true면, 잘못된 파일 등의 문제 발생

// 예를 들어 현재 cin 객체의 상태가 정상적인지 알아보기 위해서 다음과 같이 검사할 수 있다
// if (cin.good())
// {
//	 정상상태
// }

// 이와 같이 사용하며 이 밖에도 clear() 함수, ignore() 함수 등이 있다 (인터넷, 책882p 참고)

// 문자열의 입력은 cin 객체를 사용해서 입력을 받는데 메모리 공간을 미리 확보해두어야 하는 문제가 있다
// 사용자가 입력할 문자열의 길이를 예측하는 것은 불가능하기 때문이다
// 그래서 동적 할당을 사용하거나 정적으로 할당하되 입력 받을 문자열의 길이를 제한하는 방법을 사용해야 한다


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 파일 입출력
// 파일 입출력에 사용되는 클래스는 ofstream, ifstream 이다
// 이 클래스들 역시 실제 클래스는 아니고 다음과 같이 템플릿 클래스를 재정의한 클래스다
// typedef basic_ofstream<char> ofstream;
// typedef basic_ifstream<char> ifstream;
// 즉 실제 클래스는 basic_ofstream과 basic_ifstream 이 되는 것이다
// 그리고 이 클래스들은 basic_ostream과 basic_istream 의 자식 클래스가 된다
// class basic_ofstream : public basic_ostream
// class basic_ifstream : public basic_istream
// 결국 지금까지 입출력에 대해서 배운 내용들은 파일 입쳘력에 대해서도 적용되는 것이다

// 파일 열기 옵션 지정하기
// 파일을 여는 방법은 두 가지 생성자나 open() 멤버 함수를 사용할 수 있는데
// 파일 이름만 제공하면 출력, 혹은 입력용으로 파일을 생성한다
// 그런데 여기에 보다 구체적인 옵션을 제시할 수 있는 방법이 있다
// 예를 들면 이미 존재하는 파일을 지우고 새로 만들어서 연다거나 기존 파일의 끝에 이어서 쓸 수 있게 연다거나 하는 옵션 등이다
// (스트림 열기 옵션에 대해 인터넷, 책884p 참고)

// 파일을 연 다음에는 파일이 잘 열린 상태인지 확인할 필요가 있다
// 이때는 is_open() 함수를 사용해서 파일이 잘 열렸는지 확인해볼 수 있다

// 그리고 파일을 다 사용한 후에는 close() 함수를 호출해서 파일을 닫아줄 필요가 있다
// 하지만 ofstream ifstream 클래스의 소멸자에서 자동적으로 close() 함수를 호출하기 때문에
// 굳이 호출해줄 필요는 없지만 객체가 소멸되기 전에 함수를 빨리 닫을 필요가 있다면 직접 호출해주는 것이 좋다


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// <<, >> 연산자의 오버로딩
// 우리는 <<, >> 연산자를 사용해서 cout, cin 객체에 데이터를 보내거나 받아오는 작업을 해왔다
// 실제로 basic_ostream, basic_istream 클래스가 <<, >> 연산자를 오버로딩하기에 가능한 일이다
// C++ 에서 제공하는 기본적인 타입들은 이미 오버로딩이 되어있기 때문에 아무런 준비 없이 그냥 사용할 수 있었다
// 만약 직접 만든 구조체나 클래스의 객체를 cout. cin 객체와 함께 사용하고 싶다면 <<, >> 연산자를 스스로 오버로딩해서 사용하면 된다
// (자세한 방법은 인터넷, 책27장 예제27-5 참고)



//#include <Windows.h>
#include <cstdlib>

int main()
{
	//system("C:\Users\Lim-ttotti\Documents\Visual Studio 2017\Projects\C++\리 제로카라 하지마루 C++ 세카츠\C++ 고급기능\C++스타일의 입출력\입출력 클래스의 상속 계층도.jpg");
	system("aa.jpg");
	//system("tt.txt");

	return 0;
}

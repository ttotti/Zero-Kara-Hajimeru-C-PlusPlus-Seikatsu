#include "Complex.h"
#include <iostream>

using namespace std;

// 일반 함수를 사용한 연산자 오버로딩

// 이 소스코드에서 주목해야 할 부분은
// 첫번째로 인자의 개수가 틀리다 
// 일반 함수로 연산자 오버로딩을 할 때는 왼쪽과 오른쪽 피연산자의 값을 받을 수 있는 두 개의 인자가 필요하다

// 두번째로 클래스의 접근 권한과 관련한 부분이다
// Complex 클래스의 멤버 변수는 private 인데 직접 접근하고 있다

// 하지만 이 함수는 클래스의 멤버 함수가 아니기 때문에 이 멤버 변수에 접근하는 것이 불가능하다
// 그래서 Complex.h 에서 friend 를 선언했다
Complex operator+(const Complex& left, const Complex& right)
{
	// 실수부와 허수부를 각각 더한다
	int real = left.real + right.real;
	int imag = left.imaginary + right.imaginary;

	// 결과를 보관한 복소수 객체를 반환한다
	return Complex(real, imag);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 멤버 함수로 정의할 수 없는 경우

// 연산자를 오버로딩할 때 반드시 일반 함수를 사용해야 하는 경우가 있는데
// 오른쪽 피연산자가 객체인 경우가 그렇다
// 예로 << 연산자를 오버로드 하는 경우이다

// 일단 << 연산자를 오버로드하는 것이므로 함수의 이름은 operator<< 가 되야 한다
// 왼쪽 피연산자는 cout 객체이므로 cout 객체 타입인 ostream 타입을 사용하여 ostream& 처럼 만들었다
// 오른쪽 피연산자는 Complex 객체이므로 const Complex& 처럼 만들었다 (책 872p 참고)

// 하지만 멤버 함수를 사용해서 만든다면 두 가지 후보가 있는데
//---------------------------------------------------------------------
// 왼쪽 피연산자는 Complex, 오른쪽 피연산자는 cout 인 경우에 호출된다
// void Complex::operator<<(ostream& o)

// 양쪽 피연산자는 모두 Complex 인 경우에 호출된다
// void Complex::operator<<(const Complex& right)
//---------------------------------------------------------------------
// 결국 오른쪽 피연산자만 Complex인 경우는 멤버 함수를 사용해서 구현할 수 없다

// 이는 비단 << 연산자 뿐만 아니라 다른 연산자의 경우에도 모두 마찬가지로 적용하는 규칙이다

ostream& operator<< (ostream& o, const Complex& right)
{
	// 반환 값의 타입을 ostream&로 지정했다 인자로 받은 cout 객체를 다시 반환할 필요가 있기 때문이다

	// Complex 객체 right의 값을 복소수의 형태로 출력한다
	// 허수 부분을 출력하기 전에 먼저 showpos 를 먼저 cout 객체에 보냈는데 이렇게 하면 허수 부분의 값이 양수인 경우에도 +5처럼 기호를 출력한다
	// 마지막 줄에서는 noshowpos를 cout 객체에 보내서 다시 원래의 상태로 되돌렸다
	// (자세한건 인터넷, <입출력 형식 지정하기> 책875p 참고)
	o << right.Real() << showpos << right.Imaginary() << "i" << noshowpos;

	// 왜 cout 객체를 다시 반환해야 할까?
	// 이는 << 연산자의 사용법과 관련이 있다 예를 보면
	// cout << c1 << "\n";
	// 연산자 우선 순위 표를 보면 << 연산자를 동시에 사용할 경우 좌측의 연산부터 수행한다
	// 그렇기 때문에 c1 << "\n" 보다 cout << c1 수식을 먼저 수행하는 것이다
	// 우선 cout << c1 수식을 먼저 계산하고 그 결과 값과 "\n" 이 다시 << 연산을 수행하게 된다
	// 결론적으로 << 연산자를 여러 개 붙여서 사용할 수 있도록 만들기 위해 cout 객체를 반환해야 하는 것이다
	// 이해가 안된다면 인터넷, 책818p를 참고한다
	return o;
}

int main()
{
	Complex c1(1, 1);
	Complex c2(2, 2);
	Complex c3(0, 0);

	// 연산자를 사용한 덧셈
	c3 = c1 + c2; // c3 = (3,3)
	
	// 위의 코드와 동일한 수행을 한다
	// 이전에는 멤버 함수로 만들었기 때문에 c1.operator +(c2) 처럼 했지만
	// 이제는 일반 함수처럼 사용해야 한다
	c3 = operator+(c1, c2);

	Complex c4(10, 5);

	cout << c4 << endl;

	return 0;
}
#include <iostream>

using namespace std;

// 이 예제를 보면 AutoArray 클래스는 int 타입의 배열만을 관리할 수 있다
// 하지만 double 타입의 배열이나 구조체 혹은 클래스 타입의 배열을 관리할 수 있는 스마트 포인터 클래스가 필요해진다면
// AutoArray 클래스와 비슷한 클래스를 여러개 만들어야 할것이다 하지만 그 방법은 매우 많은 문제점을 가지고 있다
// 또 다른 클래스를 만들어야 하는 작업 시간과 같은 내용의 소스 코드가 중복된다는 점이다
// 다루는 배열의 타입이 다를 뿐 그 클래스들이 하는 일은 모두 동일할 것이기 때문이다
// 이런 경우 해결법은 템플릿 클래스로 만드는 것이다

// 이 예제를 약간 수정을 하면 모든 타입의 배열을 관리할 수 있는 스마트 포인터로 거듭날 수 가있다

// 템플릿 클래스를 만들기 위해서는 template 키워드를 사용한다
// typename T 부분은 컴퓨터야 이 T 대신 int float 등 여러 가지 종류의 타입 이름이 올 수 있단다 어떤 타입이 되었든 그 타입을 T 라고 부를거야 라고 하는 것이다
// 템플릿을 사용하게 되면 컴퓨터는 T 대신 사용하고자 하는 타입을 넣어서 새로운 클래스를 만들게 된다
// 이것이 컴퓨터에게 코딩을 맡긴다는 것인데 물론 그렇게 만들어진 소스 코드가 눈에 보이는 것은 아니지만 컴퓨터 내부적으로는 그 클래스가 존재한다
// 예제에 나오는 T를 템플릿 매개 변수(Template Parameter) 라고 부르는데 템플릿 매개 변수는 얼마든지 많이 올 수 있다
// 또한 템플릿은 일반 클래스를 템플릿 클래스로 만들 수 있고 일반함수를 템플릿 함수로 만들 수 있다
// 또한 템플릿 클래스가 아닌 일반 클래스의 멤버 함수를 템플릿으로 만드는 것이 가능하다
template <typename T>

class AutoArray
{
private:
	// 수정 전 int* _ptr;
	T* _ptr;

public:
	// 생성자를 T 타입의 배열을 받게 수정했다
	// T 타입은 사용자가 어떤 타입을 원하느냐에 따라서 char도 되고 double도 되고 구조체나 클래스의 타입도 될 수 있다
	AutoArray(T* ptr) // 수정 전(int* ptr)
	{
		_ptr = ptr;
	}
	~AutoArray()
	{
		delete[] _ptr;
	}

	// AutoArray 객체를 실제 배열처럼 사용할 수 있게 만들기 위해서 []연산자를 오버로딩 했다
	// 반환 값이 단순히 int 가 아니라 int&라는 점을 주의해서 봐둘 필요가 있다
	// 이렇게 하지 않으면 arr[0]=100 처럼 값을 대입할 수 없다
	// 수정 전 int&
	T& operator[](int index)
	{
		return _ptr[index];
	}
};

// 템플릿 매개 변수는 얼마든지 많이 올 수 있는데
// 예를 들어 서로 다른 타입의 배열 두 개를 보관할 수 있는 템플릿 클래스는 다음과 같이 만들 수 있다
// typename 대신 class 라고 적어주어도 무방하다 어느것을 사용하건 아무런 차이가 없다
template <typename A, typename B, int MAX>

class TwoArray
{
	// 중간 생략
	A arr1[MAX];
	B arr2[MAX];
};

// 템플릿 함수
// 모든 타입에 대해서 사용할 수 있는 max() 함수이다
template <typename Q>

// 인자와 반환 값의 타입으로 템플릿 매개 변수 Q를 사용한다
Q max(Q a, Q b)
{
	return (a > b ? a : b);
}

int main()
{
	// 수정 전 AutoArray arr(new int[100]);
	// 이제 사용하는 쪽에서 T가 어떤 타입이 될지를 지정해주면서 사용해야 한다
	// 방법은 AutoArray<float> 와 같은 표현으로 사용한다 T 대신에 float를 대입한 것으로 생각하면 된다
	AutoArray<float> arr(new float[100]);
	AutoArray<int> arr2(new int[100]);

	// AutoArray객체 arr가 마치 배열인 것처럼 사용할 수 있다
	// arr[0] = 100;
	arr[0] = 99.99f;
	arr2[0] = arr[0]; // ?
	// arr2 = arr; // 오류 // 서로다른 타입의 클래스를 대입할 수 없다? /

	///////////////////////////////////////////////////////

	// 여러개의 템플릿 매개 변수 사용
	TwoArray<char, double, 20> arr3;

	// 컴퓨터는 위의 코드를 보고 내부적으로 다음과 같은 클래스를 만들게 된다
	/*class TwoArray
	{
		char arr1[20];
		double arr2[20];
	};*/

	///////////////////////////////////////////////////////

	// 임의의 타입 Q 를 사용해서 만든 max() 함수에 int 타입과 double 타입의 인자를 사용해서 max() 함수를 호출했다
	// 템플릿 클래스와 크게 다른점은 없지만 템플릿 함수를 호출할때의 방법이 다르다
	// 클래스는 클래스 이름<타입> 형식으로 호출하지만 템플릿 함수는 그렇지 않다
	// 템플릿 함수의 경우에는 예제에서 처럼 타입을 명시하지 않고 그냥 사용하는 것이 가능하다
	// 왜냐하면 입력하는 인자의 타입을 통해서 Q 타입 대신에 어떤 타입을 대입해야 하는지 유추할 수 있기 때문이다
	int i1 = 5, i2 = 3;
	// 여기 max 함수는 int 타입의 인자를 사용했기 때문에 Q 대신 int를 사용해야 한다는 사실을 알 수가 있고
	// 컴퓨터는 Q 대신에 int를 대입해서 새로운 max 함수를 만들어낸다
	int i3 = max(i1, i2); // i3 = 5

	double d1 = 0.9, d2 = 1.0;
	double d3 = max(d1, d2); // d3 = 1.0

	return 0;
}

// 템플릿 사용 시 유의할 점
// 템플릿은 지금 까지 배워왔던 C++의 다른 기능들과는 약간 차원이 다른 기능이다
// 왜냐하면 클래스나 함수 자체를 만들어내기 때문이다 구체적으로 어떤 점이 다른지 알아보자

// 템플릿은 컴파일 시간에 코드를 만들어낸다
// 컴파일 시간(Compile time) 과 실행 시간(Run Time) 이라는 용어가 있는데
// 컴파일 시간이란 소스 코드를 컴파일하고 있는 그 순간을 의미하며
// 실행 시간이란 컴파일한 프로그램이 실제로 컴퓨터 상에서 실행되고 있는 순간을 의미한다
// 그렇기 때문에 템플릿은 프로그램이 실행되는 도중이 아니라 소스 코드를 컴파일하는 도중에 클래스나 함수를 만들어 낸다 라는 뜻이다
// 템플릿이 새로운 클래스나 함수를 만드는 동작을 컴파일 시간에 수행한다는 것은 중요한 의미가 있다
// 만약에 프로그램이 실행되는 도중에 클래스나 함수를 만들게 되면 프로그램의 실행 속도가 느려지기 때문이다
// 하지만 프로그램이 실행되기 전에 미리 만들어져 있기 때문에 템플릿을 많이 사용하더라도 프로그램이 느려지는 일은 없다
// 대신 컴파일하는 도중에 클래스나 함수를 생성해야 하므로 컴파일이 오래 걸리는 단점이 생긴다
// 하지만 이는 충분히 감당할 수 있는 단점이다 매번 실행할 때마다 느려지는 것보다 컴파일 할 때 한 번만 느려지는 게 훨씬 낫기 때문이다

// 템플릿 함수의 정의는 헤더 파일에 놓아야 한다
// 소스 코드가 여러 파일로 이루어져 있는 경우에 함수의 정의를 구현 파일에 놓는 것이 일반적이다
// 만약에 함수의 정의를 헤더 파일에 놓게 되면 그 헤더 파일을 포함하는 다른 여러 구현 파일에서 중복 정의되는 결과를 낳기 때문이다
// 하지만 템플릿 함수는 반드시 헤더 파일에 놓여야 된다
// 템플릿 함수를 정의하는 것의 의미는 보통의 함수를 정의하는 것과는 다른 의미가 있기 때문이다
// 템플릿 함수를 정의하는 것은 실제로 함수를 정의하는 의미라기 보다는 컴퓨터에게 함수를 만드는 방법을 가르쳐주는 의미를 갖기 때문에 이런 예외적인 규칙을 갖게된다
// 여기서 말하는 템플릿 함수란 일반 함수와 멤버 함수 모두를 말하는 것이다
// 중요한 것은 템플릿 클래스의 일반 멤버 함수도 여기에 포함된다
// 다시 말해서 템플릿 클래스의 멤버 함수는 템플릿 함수가 아니더라도 헤더 파일에 위치해야 한다

// 그렇다고 방법이 없는건 아니다
// 템플릿 함수를 구현 파일에 놓을 수도 있다
// 템플릿 함수의 정의를 헤더 파일에 놓게 되면 소스 코드가 지저분해지기 쉽다
// 그래서 C++ 에서는 템플릿 함수의 정의를 구현 파일에 놓을 수 있게 export라는 키워드를 제공한다
// 템플릿 함수의 정의를 구현 파일에 놓고 그 앞에 export라는 키워드를 붙여주면 되는 것이다

// 네임스페이스와 스소 파일 중에서 어느 것이 더 큰 범주에 속할까?
// 다시 말해서 한 네임스페이스 안에 여러 파일이 포함될 수 있는 것일까? 아니면 한 파일 안에 여러 네임스페이스가 포함될 수 있는 것일까?
// 답은 둘 다 아니다 네임스페이스와 소스 파일은 독립적인 관계다
// 하나의 네임스페이스가 여러 파일에 걸쳐서 존재할 수도 있고 한 파일 안에 여러 네임스페이스가 존재할 수도 있다(자세한 내용은 인터넷, 책845p 참고)
// 예로 멍멍이와 야옹이 예제를 보면 한 파일 안에 Dog과 Cat 네임스페이스가 존재했었다
// 이번에는 C++의 표준 라이브러리를 보면 표준 라이브러리와 관련된 코드들은 모두 std 네임스페이스 안에 소속되어 있지만
// 이 코드들은 수백 개의 소스 파일에 나뉘어서 존재한다
// 실제로 네임스페이스를 사용할 때는 거의 대부분 후자와 같은 방식을 사용한다
// 왜냐하면 네임스페이스의 목적은 수많은 파일과 코드를 관련된 것끼리 모으는 것이기 때문이다
// 그렇기 때문에 네임스페이스가 여러 소스 파일을 담는 논리적인 가방 이라고 생각하면 된다

// 이 예제에서 가장 중요한 부분은 cat.h와 cat.cpp 모두에서 네임스페이스 블록을 만들어주었다는 것이다
// 서로 다른 파일에서 만든 Cat 네임스페이스지만 컴퓨터 입장에서는 모두 동일한 Cat네임스페이스가 된다
// 이런 방식을 사용해서 수많은 파일에 걸쳐서 존재하는 코드들을 하나의 네임스페이스 안에 담을 수 있는 것이다

#include "cat.h"
#include "dog.h"

// NoNamespace.cpp 에서 정의한 g를 사용하기 위한 준비
extern int g;

// 중첩된 네임스페이스
namespace Data
{
	namespace User
	{
		int number;

		namespace Free
		{
			int number2;
		}
	}
}

// 네임스페이스를 별명으로 부르기
namespace this_namespace_has_a_very_long_name
{
	int n;
}

// 긴 이름의 네임스페이스에 별명을 붙여준다
namespace oh = this_namespace_has_a_very_long_name;
// 여러번 중첩된 네임스페이스에 별명 붙이기
namespace ah = Data::User::Free;

int main()
{
	Cat::CreateAll();
	Dog::CreateAll();

	// 그 밖에도 네임스페이스가 가진 기능들이 있다

	// 이름 없는 네임스페이스 (NoNamespace.cpp 설명 참고)
	g = 200; // 오류

	// 중첩된 네임스페이스
	// 중첩된 네임스페이스에 접근하기 위해서는 반복적으로 영역 지정 연산자를 사용하면 된다
	// 이는 Data 네임스페이스 안에 User 네임스페이스 안에 정의한 number를 의미하게 된다
	int user_number = Data::User::number;

	// 네임스페이스를 별명으로 부르기
	// 아주 긴 이름의 네임스페이스에 oh 라는 짧은 별명을 붙여주고 있다
	// 이제 이 네임스페이스는 oh라는 별명으로도 부를 수 있게 된다
	// 그리고 여러 번 중첩된 네임스페이스에도 별명을 붙여줄 수 있다
	oh::n = 100;
	ah::number2 = 100;

	// 이 처럼 네임스페이스는 소스 코드를 구조적으로 만드는 데 많은 도움을 주는 기능이다
	// 연습용 프로그램을 작성할 때마다 네임스페이스를 사용하는 습관을 들이면 실전에서도 어렵지 않게 적용할 수 있을 것이다

	return 0;
}
#include <list> // list 클래스를 사용하기 위해서는 list 헤더 파일을 포함해야 한다
#include <iostream>

// STL 컨테이너
// 컨테이너(Containers)란 다수의 정보를 담는 역할을 하는 클래스를 말한다
// 보통 링크드 리스트나 동적인 배열 그리고 큐(Queue) 나 맵(Map) 등의 클래스들을 컨테이너 라고 부른다

int main()
{
	// int 타입을 담을 링크드 리스트 생성
	std::list<int> intList;

	// 0~9까지 링크드 리스트에 넣는다
	for (int i = 0; i < 10; ++i)
		// list 클래스의 push_back() 멤버 함수를 사용해서 노드를 추가한다
		// 이름에서 알 수 있는 것처럼 리스트의 뒤쪽에 노드를 추가하는 역할을 한다
		intList.push_back(i);

	// 5를 찾아서 제겋나다
	intList.remove(5);

	// 링크드 리스트의 내용을 출력한다
	// iterator 클래스의 객체인 it를 생성하고 있다
	// std::list<int>:: 처럼 써준 것은 iterator 클래스를 정의한 위치를 알려주기 위한 용도일 뿐이다
	// 중요한 것은 iterator 클래스의 객체를 생성하고 있다는 점인데
	// 바로 이 iterator 클래스가 노드의 위치를 가리키는 역할을 한다
	// 즉 iterator 객체 it 를 사용해서 첫번째 노드부터 마지막 노드까지 반복적으로 가리키려는 것이다
	std::list<int>::iterator it;
	// intList.begin()과 intList.end()함수를 호출하고 있는데 각각 리스트의 첫번째 노드와 마지막 노드의 위치를 반환하는 멤버 함수다
	// 또한 ++it에 의해서 it는 다음 노드를 가리키게 되는데
	// 마치 배열의 원소를 가리키는 포인터에 ++p처럼 해주면 다음 원소를 가리키게 되는 것과 같다
	// iterator 클래스를 만든 사람들이 일부러 포인터를 흉내내기 위해서 ++ 연산자를 오버로드 한것이다
	// 이해가 안되거나 자세한것은 인터넷과 책864p를 참고한다
	for (it = intList.begin(); it != intList.end(); ++it)
		// 마지막으로 *it처럼 노드에 보관된 값을 읽어오게 만든다
		// 이 역시 포인터에 *p처럼 해주면 포인터가 가리키는 곳에 보관한 값을 읽어오게 만드는것과 같다
		// 마찬가지로 iterator 클래스를 만든 사람들이 일부러 포인터를 흉내내기 위해 * 연산자를 오버로딩한 것이다
		std::cout << *it << "\n";

	return 0;
}
// 우리가 만들었던 링크드 리스트보다 좋은 점
// 방금 본 list 클래스가 우리가 만들었던 링크드 리스트보다 눈에 띄게 좋은 점이 하나 있다
// 우리가 만들었던 링크드 리스트 클래스는 모든 타입을 담기 위해 void* 타입을 사용했기 때문에 노드에 보관된 정보를 제거하는데 문제가 있었다
// 그리고 그 문제를 해결하기 위해 함수 포인터를 쓰는 등 복잡한 구조가 될 수 밖에 없었고 링크드 리스트 클래스의 사용법 역시 복잡해졌다 (프로젝트 성적표 ver3.x)
// 하지만 템플릿 클래스인 list 클래스의 경우에는 그런 문제가 없다
// 예를 들어 list<Student> 라고 해주면 Student 객체를 담을 수 있는 새로운 list 클래스가 생겨나는 것이기 때문이다
// 즉 우리가 직접 Student 객체 전용의 링크드 리스트를 구현한 것과 동일한 효과를 갖는 것이다

// STL에서는 다양한 STL 컨테이너를 제공한다 자세한건 인터넷, 책865p를 참고한다
// 중요한 것은 이런 컨테이너 클래스들이 모두 유사한 인터페이스를 가진다는 점이다
// 예를 들어 list 클래스가 아닌 vector 클래스를 사용하는 코드로 만들고 싶다면 간단하게 list라고 적힌 부분을 vector 라고만 바꿔주면 된다
// 어파피 사용법은 동일하기 때문이다
// 바로 이것이 STL의 철학이며 최소한의 소스 수정으로 컨테이너를 다른 것으로 교체할 수 있는 것이다
// 예를 들어 노드(혹은 원소) 에 빨리 접근하는 것이 중요한 프로그램이 있다면 vector 클래스를 사용하는 것이 좋다
// 배열이 링크드 리스트 보다 노드에 대한 접근 속도가 빠르기 때문이다
// 그런데 나중에 프로그램의 성격이 변해서 노드의 추가나 삭제가 빈번하게 일어난다면 list 클래스를 바꿀 필요가 있다
// 링크드 리스트는 노드를 추가하고 제거하는 속도가 배열보다 훨씬 빠르기 때문이다
// STL을 사용하면 이렇게 컨테이너 클래스를 바꿔야 하는 경우에도 단지 몇 줄의 코드만 수정하면 된다
// 이런 특징은 프로그램의 개발이나 유지보수 시간을 단축하는 데 큰 도움이 된다
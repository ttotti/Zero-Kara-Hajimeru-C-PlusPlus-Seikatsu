#include <iostream>

using namespace std;

int main()
{
	double target = 20.1;

	double& ref = target; // 레퍼런스 쉽게말해 변수의 별명이다 target은 ref라는 새로운 이름을 가지게 된다

	cout << "ref = " << ref << endl;
	cout << "target = " << target << endl;
	cout << "&ref = " << &ref << endl; // 주소를 통해 접근하므로 값이 변하면 같이 변한다
	cout << "&target = " << &target << endl;

	ref = 100;

	cout << "ref = " << ref << endl;
	cout << "target = " << target << endl; // 컴퓨터 내부적으로 보았을때 포인터와 같은 방식으로 동작하지만
										   // 포인터는 자체적인 메모리 공간을 가지고 있는 반면 레퍼런스의 경우 자체적인 메모리 공간은 존재하지 않고 오로지 이름만 존재한다

	cout << "target의 크기 = " << sizeof(target) << endl; // 포인터의 경우 따로 4바이트의 공간을 가지고 있지만 레퍼런스의 경우 메모리 공간이 따로 존재하지 않고
	cout << "ref의 크기 = " << sizeof(ref) << endl; // 이름만 참조하고 있으므로 참조하고 있는 변수와 크기가 같다

	///////////////////////////////////////////////////////

	float a = 100.0f;
	float b = 12.34f;

	// 레퍼런스 변수를 정의 할때는 반드시 초기화를 해준다
	float& c = a; // 변수 a를 레퍼런스변수 c가 참조하게 만든다 한번 초기화하면 끝까지 바뀌지않는다

	c = 12.323f;
	c = b; // 레퍼런스 변수에 새로운 값을 참조하게 만든것 같지만 레퍼런스 변수를 처음 정의할 때 외에는 다른 변수를 참조하게 만들 수 없다
	c = 56.78f; // 변수 a의 값은 결과적으로 56.78f의 값을 가지게 된다
	
	//////////////////////////////////////////////////////

	char cc = 'A';
	const char& r = cc;
	cc = 'B'; // 성공 변수 c는 const 속성이 아니므로 변경가능하다
	// r = 'C'; 오류 const 속성을 가진 레퍼런스 변수의 경우 자신의 값을 변경할 수 없게 된다
	cout << r << endl;
	cout << cc << endl;
	// 이런 특징은 함수와 함께 사용시 제 힘을 발휘한다 350쪽

	///////////////////////////////////////////////////////

	const int& rci = 100; // 성공 const 속성의 레퍼런스는 상수에 대한 별명으로 쓰일 수 있다
	//int& ri = 100; 오류
	// 레퍼런스는 변수를 참조하게 만들어졌기 때문에 바로 상수를 참조할 수 없다 그래서 이 경우에는 그 상수 값을 가지는 임시변수(객체)를 하나 만든 후에 그 임시변수를 참조하게 만든다

	char q = 'A';
	const int& rcq = q; // 레퍼런스는 다른 타입을 참조하는것이 가능하다
	//int& ri = q; 오류
	// 이 경우 char타입을 int으로 형변환하여 임시변수를 만들고 그 안에 값을 넣은후 그 임시변수를 참조한다
	// 하지만 레퍼런스를 통해 값을 바꿀수있더라도 참조하고있는 임시변수가 값이 바뀌므로 의미가 없다 그래서 값을 바꿀수없는 const속성만 다른타입을 참조하는것이 가능하다

	return 0;
}